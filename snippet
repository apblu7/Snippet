@RestController
@RequestMapping("/mock")
public class MockController {

    private final ObjectMapper mapper = new ObjectMapper();

    @GetMapping
    public ResponseEntity<?> getMockedData(@RequestParam Map<String, String> params) throws IOException {
        // 페이징 값 추출
        int pageNo = Integer.parseInt(params.getOrDefault("pageNo", "1"));
        int numOfRows = Integer.parseInt(params.getOrDefault("numOfRows", "10"));

        // 템플릿 로딩
        JsonNode template = mapper.readTree(new ClassPathResource("mock/template.json").getFile());

        // 데이터 로딩
        List<Map<String, Object>> items = mapper.readValue(
                new ClassPathResource("mock/items.json").getInputStream(),
                new TypeReference<>() {}
        );

        // 필터링 파라미터 추출 (pageNo, numOfRows 제외)
        Map<String, String> filterParams = new HashMap<>(params);
        filterParams.remove("pageNo");
        filterParams.remove("numOfRows");

        // 필터링 적용 (필터 파라미터 있을 때만)
        if (!filterParams.isEmpty()) {
            items = filterItems(items, filterParams);
        }

        // 페이징
        int totalCount = items.size();
        int from = (pageNo - 1) * numOfRows;
        int to = Math.min(from + numOfRows, totalCount);
        List<Map<String, Object>> paged = (from < totalCount) ? items.subList(from, to) : Collections.emptyList();

        // 템플릿 구성
        ((ObjectNode) template.at("/response/body")).put("numOfRows", numOfRows);
        ((ObjectNode) template.at("/response/body")).put("pageNo", pageNo);
        ((ObjectNode) template.at("/response/body")).put("totalCount", totalCount);
        ((ObjectNode) template.at("/response/body/items")).set("item", mapper.valueToTree(paged));

        return ResponseEntity.ok(template);
    }

    // 필터링 로직 분리
    private List<Map<String, Object>> filterItems(List<Map<String, Object>> list, Map<String, String> filters) {
        return list.stream()
                .filter(item -> filters.entrySet().stream().allMatch(entry -> {
                    Object field = item.get(entry.getKey());
                    return field != null && field.toString().toLowerCase().contains(entry.getValue().toLowerCase());
                }))
                .collect(Collectors.toList());
    }
}