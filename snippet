@RestController
@RequestMapping("/mock")
public class MockController {

    private final ObjectMapper mapper = new ObjectMapper();

    // 필터링에서 제외할 쿼리 파라미터
    private static final List<String> EXCLUDED_FILTER_KEYS = List.of("pageNo", "numOfRows");

    @GetMapping
    public ResponseEntity<?> getMockedData(@RequestParam Map<String, String> params) throws IOException {
        // 1. 페이징 추출
        int pageNo = Integer.parseInt(params.getOrDefault("pageNo", "1"));
        int numOfRows = Integer.parseInt(params.getOrDefault("numOfRows", "10"));

        // 2. 템플릿과 데이터 로드
        JsonNode template = mapper.readTree(new ClassPathResource("mock/template.json").getFile());
        List<Map<String, Object>> items = mapper.readValue(
                new ClassPathResource("mock/items.json").getInputStream(),
                new TypeReference<>() {}
        );

        // 3. 필터링 파라미터 추출
        Map<String, String> filterParams = params.entrySet().stream()
                .filter(e -> !EXCLUDED_FILTER_KEYS.contains(e.getKey()))
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));

        Collection<String> rawValues = filterParams.values();

        // 4. 키-값 매칭 필터
        if (!filterParams.isEmpty()) {
            items = filterByKeyValueMatch(items, filterParams);
        }

        // 5. 전체 값이 특정 필드에 포함되는지 검사 (예: name 필드)
        if (!rawValues.isEmpty()) {
            items = filterByValuesInSingleField(items, rawValues, "name");
        }

        // 6. 페이징
        int totalCount = items.size();
        int from = (pageNo - 1) * numOfRows;
        int to = Math.min(from + numOfRows, totalCount);
        List<Map<String, Object>> paged = (from < totalCount) ? items.subList(from, to) : Collections.emptyList();

        // 7. 템플릿 조립
        ((ObjectNode) template.at("/response/body")).put("numOfRows", numOfRows);
        ((ObjectNode) template.at("/response/body")).put("pageNo", pageNo);
        ((ObjectNode) template.at("/response/body")).put("totalCount", totalCount);
        ((ObjectNode) template.at("/response/body/items")).set("item", mapper.valueToTree(paged));

        return ResponseEntity.ok(template);
    }

    // 키-값 기반 필터
    private List<Map<String, Object>> filterByKeyValueMatch(List<Map<String, Object>> list, Map<String, String> filters) {
        return list.stream()
                .filter(item -> filters.entrySet().stream().allMatch(entry -> {
                    Object field = item.get(entry.getKey());
                    return field != null && field.toString().toLowerCase().contains(entry.getValue().toLowerCase());
                }))
                .collect(Collectors.toList());
    }

    // 파라미터 값이 특정 필드에 모두 포함되는지 검사 (AND 조건)
    private List<Map<String, Object>> filterByValuesInSingleField(List<Map<String, Object>> list, Collection<String> values, String targetField) {
        return list.stream()
                .filter(item -> {
                    Object field = item.get(targetField);
                    if (field == null) return false;
                    String fieldValue = field.toString().toLowerCase();
                    return values.stream().allMatch(val -> fieldValue.contains(val.toLowerCase()));
                })
                .collect(Collectors.toList());
    }
}